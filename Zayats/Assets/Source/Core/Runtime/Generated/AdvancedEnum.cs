// <auto-generated>
// This file has been autogenerated by Kari.
// </auto-generated>

#pragma warning disable

namespace Zayats.Core.Generated
{
    using System;
    [Serializable]
    public partial struct ItemUsabilityArray<T>
    {
        public /*readonly*/ T[] Values;
        private ItemUsabilityArray(T[] values) => Values = values;
        public static ItemUsabilityArray<T> Create() => new ItemUsabilityArray<T>(new T[3]);
        public readonly ref T GetRef(Zayats.Core.ItemUsability key)
        {
            return ref Values[(int) key];
        }
        public readonly T Get(Zayats.Core.ItemUsability key)
        {
            return Values[(int) key];
        }
        public readonly void Set(Zayats.Core.ItemUsability key, T value)
        {
            Values[(int) key] = value;
        }
        public readonly ref T NoneRef => ref Values[(int) Zayats.Core.ItemUsability.None];
        public T None
        {
            readonly get => Values[(int) Zayats.Core.ItemUsability.None];
            set => Values[(int) Zayats.Core.ItemUsability.None] = value;
        }
        public readonly ref T NotEnoughSpotsRef => ref Values[(int) Zayats.Core.ItemUsability.NotEnoughSpots];
        public T NotEnoughSpots
        {
            readonly get => Values[(int) Zayats.Core.ItemUsability.NotEnoughSpots];
            set => Values[(int) Zayats.Core.ItemUsability.NotEnoughSpots] = value;
        }
        public readonly ref T UsableRef => ref Values[(int) Zayats.Core.ItemUsability.Usable];
        public T Usable
        {
            readonly get => Values[(int) Zayats.Core.ItemUsability.Usable];
            set => Values[(int) Zayats.Core.ItemUsability.Usable] = value;
        }
        public static implicit operator T[](ItemUsabilityArray<T> a) => a.Values;
        public readonly T[] Array => Values;
        public readonly ref T this[Zayats.Core.ItemUsability key] => ref GetRef(key);
        public readonly ref T this[int index] => ref Values[index];
        public readonly int Length => 3;
        public static bool operator==(ItemUsabilityArray<T> a, ItemUsabilityArray<T> b)
        {
            for (int i = 0; i < a.Length; i++)
                if (!a.Values[i].Equals(b.Values[i]))
                    return false;
            return true;
        }
        public static bool operator!=(ItemUsabilityArray<T> a, ItemUsabilityArray<T> b)
        {
            return !(a == b);
        }
        public void FixSize()
        {
            if (Values is null || Values.Length != Length)
                System.Array.Resize(ref Values, Length);
        }
    }
    [Serializable]
    public partial struct ThingArray<T>
    {
        public /*readonly*/ T[] Values;
        private ThingArray(T[] values) => Values = values;
        public static ThingArray<T> Create() => new ThingArray<T>(new T[11]);
        public readonly ref T GetRef(Zayats.Core.ThingKind key)
        {
            return ref Values[(int) key];
        }
        public readonly T Get(Zayats.Core.ThingKind key)
        {
            return Values[(int) key];
        }
        public readonly void Set(Zayats.Core.ThingKind key, T value)
        {
            Values[(int) key] = value;
        }
        public readonly ref T PlayerRef => ref Values[(int) Zayats.Core.ThingKind.Player];
        public T Player
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Player];
            set => Values[(int) Zayats.Core.ThingKind.Player] = value;
        }
        public readonly ref T EternalMineRef => ref Values[(int) Zayats.Core.ThingKind.EternalMine];
        public T EternalMine
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.EternalMine];
            set => Values[(int) Zayats.Core.ThingKind.EternalMine] = value;
        }
        public readonly ref T RegularMineRef => ref Values[(int) Zayats.Core.ThingKind.RegularMine];
        public T RegularMine
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.RegularMine];
            set => Values[(int) Zayats.Core.ThingKind.RegularMine] = value;
        }
        public readonly ref T CoinRef => ref Values[(int) Zayats.Core.ThingKind.Coin];
        public T Coin
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Coin];
            set => Values[(int) Zayats.Core.ThingKind.Coin] = value;
        }
        public readonly ref T RespawnPointRef => ref Values[(int) Zayats.Core.ThingKind.RespawnPoint];
        public T RespawnPoint
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.RespawnPoint];
            set => Values[(int) Zayats.Core.ThingKind.RespawnPoint] = value;
        }
        public readonly ref T TotemRef => ref Values[(int) Zayats.Core.ThingKind.Totem];
        public T Totem
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Totem];
            set => Values[(int) Zayats.Core.ThingKind.Totem] = value;
        }
        public readonly ref T RabbitRef => ref Values[(int) Zayats.Core.ThingKind.Rabbit];
        public T Rabbit
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Rabbit];
            set => Values[(int) Zayats.Core.ThingKind.Rabbit] = value;
        }
        public readonly ref T TowerRef => ref Values[(int) Zayats.Core.ThingKind.Tower];
        public T Tower
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Tower];
            set => Values[(int) Zayats.Core.ThingKind.Tower] = value;
        }
        public readonly ref T HorseRef => ref Values[(int) Zayats.Core.ThingKind.Horse];
        public T Horse
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Horse];
            set => Values[(int) Zayats.Core.ThingKind.Horse] = value;
        }
        public readonly ref T SnakeRef => ref Values[(int) Zayats.Core.ThingKind.Snake];
        public T Snake
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Snake];
            set => Values[(int) Zayats.Core.ThingKind.Snake] = value;
        }
        public readonly ref T BoozeRef => ref Values[(int) Zayats.Core.ThingKind.Booze];
        public T Booze
        {
            readonly get => Values[(int) Zayats.Core.ThingKind.Booze];
            set => Values[(int) Zayats.Core.ThingKind.Booze] = value;
        }
        public static implicit operator T[](ThingArray<T> a) => a.Values;
        public readonly T[] Array => Values;
        public readonly ref T this[Zayats.Core.ThingKind key] => ref GetRef(key);
        public readonly ref T this[int index] => ref Values[index];
        public readonly int Length => 11;
        public static bool operator==(ThingArray<T> a, ThingArray<T> b)
        {
            for (int i = 0; i < a.Length; i++)
                if (!a.Values[i].Equals(b.Values[i]))
                    return false;
            return true;
        }
        public static bool operator!=(ThingArray<T> a, ThingArray<T> b)
        {
            return !(a == b);
        }
        public void FixSize()
        {
            if (Values is null || Values.Length != Length)
                System.Array.Resize(ref Values, Length);
        }
    }
}

#pragma warning restore
