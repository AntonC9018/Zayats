// <auto-generated>
// This file has been autogenerated by Kari.
// </auto-generated>

#pragma warning disable

namespace Common.Unity.Generated
{
    using System;
    [Serializable]
    public partial struct ShaderPropertyArray<T>
    {
        public /*readonly*/ T[] Values;
        private ShaderPropertyArray(T[] values) => Values = values;
        public static ShaderPropertyArray<T> Create() => new ShaderPropertyArray<T>(new T[3]);
        public readonly ref T GetRef(Common.Unity.ShaderProperty key)
        {
            return ref Values[(int) key];
        }
        public readonly T Get(Common.Unity.ShaderProperty key)
        {
            return Values[(int) key];
        }
        public readonly void Set(Common.Unity.ShaderProperty key, T value)
        {
            Values[(int) key] = value;
        }
        public readonly ref T MainColorRef => ref Values[(int) Common.Unity.ShaderProperty.MainColor];
        public T MainColor
        {
            readonly get => Values[(int) Common.Unity.ShaderProperty.MainColor];
            set => Values[(int) Common.Unity.ShaderProperty.MainColor] = value;
        }
        public readonly ref T BaseMapRef => ref Values[(int) Common.Unity.ShaderProperty.BaseMap];
        public T BaseMap
        {
            readonly get => Values[(int) Common.Unity.ShaderProperty.BaseMap];
            set => Values[(int) Common.Unity.ShaderProperty.BaseMap] = value;
        }
        public readonly ref T EmissionColorRef => ref Values[(int) Common.Unity.ShaderProperty.EmissionColor];
        public T EmissionColor
        {
            readonly get => Values[(int) Common.Unity.ShaderProperty.EmissionColor];
            set => Values[(int) Common.Unity.ShaderProperty.EmissionColor] = value;
        }
        public static implicit operator T[](ShaderPropertyArray<T> a) => a.Values;
        public readonly T[] Array => Values;
        public readonly ref T this[Common.Unity.ShaderProperty key] => ref GetRef(key);
        public readonly ref T this[int index] => ref Values[index];
        public readonly int Length => 3;
        public static bool operator==(ShaderPropertyArray<T> a, ShaderPropertyArray<T> b)
        {
            for (int i = 0; i < a.Length; i++)
                if (!a.Values[i].Equals(b.Values[i]))
                    return false;
            return true;
        }
        public static bool operator!=(ShaderPropertyArray<T> a, ShaderPropertyArray<T> b)
        {
            return !(a == b);
        }
        public void FixSize()
        {
            if (Values is null || Values.Length != Length)
                System.Array.Resize(ref Values, Length);
        }
    }
}

#pragma warning restore
